<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0056)http://www.haskell.org/haskellwiki/99_questions/80_to_89 -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		
				<meta name="keywords" content="99 questions/80 to 89,99 questions/Solutions/81,99 questions/Solutions/82,99 questions/Solutions/84,99 questions/Solutions/87,99 questions/Solutions/88,99 questions/Solutions/89,H-99: Ninety-Nine Haskell Problems,99 questions/Solutions/86,99 questions/Solutions/85,99 questions/Solutions/80">
		<link rel="shortcut icon" href="http://www.haskell.org/favicon.ico">
		<link rel="search" type="application/opensearchdescription+xml" href="http://www.haskell.org/haskellwiki/opensearch_desc.php" title="HaskellWiki (English)">
		<link title="Creative Commons" type="application/rdf+xml" href="http://www.haskell.org/haskellwiki/index.php?title=99_questions/80_to_89&action=creativecommons" rel="meta">
		<link rel="copyright" href="http://www.haskell.org/haskellwiki/HaskellWiki:Copyrights">
<link rel="alternate" type="application/rss+xml" title="HaskellWiki RSS Feed" href="http://www.haskell.org/haskellwiki/index.php?title=Special:Recentchanges&feed=rss">
<link rel="alternate" type="application/atom+xml" title="HaskellWiki Atom Feed" href="http://www.haskell.org/haskellwiki/index.php?title=Special:Recentchanges&feed=atom">
		<title>99 questions/80 to 89 - HaskellWiki</title>
		<style type="text/css" media="screen, projection">/*<![CDATA[*/
			@import "/wikistatic/skins//common/shared.css?116";
			@import "/wikistatic/skins//hawiki/main.css?116";
		/*]]>*/</style>
		<link rel="stylesheet" type="text/css" media="print" href="./99 questions 80 to 89 - HaskellWiki_files/commonPrint.css">
		<!--[if lt IE 5.5000]><style type="text/css">@import "/wikistatic/skins//hawiki/IE50Fixes.css?116";</style><![endif]-->
		<!--[if IE 5.5000]><style type="text/css">@import "/wikistatic/skins//hawiki/IE55Fixes.css?116";</style><![endif]-->
		<!--[if IE 6]><style type="text/css">@import "/wikistatic/skins//hawiki/IE60Fixes.css?116";</style><![endif]-->
		<!--[if IE 7]><style type="text/css">@import "/wikistatic/skins//hawiki/IE70Fixes.css?116";</style><![endif]-->
		<!--[if lte IE 7]><script type="text/javascript" src="/wikistatic/skins//hawiki/IEFixes.js?116"></script>
		<meta http-equiv="imagetoolbar" content="no" /><![endif]-->
                                                <script type="text/javascript" async="" src="./99 questions 80 to 89 - HaskellWiki_files/ga.js"></script><script type="text/javascript">
                        var isMSIE55 = (window.showModalDialog && window.clipboardData && window.createPopup); /*alert("test: " + isMSIE55);*/</script>

		<script type="text/javascript">/*<![CDATA[*/
var skin = "hawiki";
var stylepath = "/wikistatic/skins/";
var wgArticlePath = "/haskellwiki/$1";
var wgScriptPath = "/haskellwiki";
var wgScript = "/haskellwiki/index.php";
var wgServer = "http://www.haskell.org";
var wgCanonicalNamespace = "";
var wgCanonicalSpecialPageName = false;
var wgNamespaceNumber = 0;
var wgPageName = "99_questions/80_to_89";
var wgTitle = "99 questions/80 to 89";
var wgAction = "view";
var wgRestrictionEdit = [];
var wgRestrictionMove = [];
var wgArticleId = "2473";
var wgIsArticle = true;
var wgUserName = null;
var wgUserGroups = null;
var wgUserLanguage = "en";
var wgContentLanguage = "en";
var wgBreakFrames = false;
var wgCurRevisionId = "44302";
var wgVersion = "1.12.0";
var wgEnableAPI = true;
var wgEnableWriteAPI = false;
/*]]>*/</script>

		<script type="text/javascript" src="./99 questions 80 to 89 - HaskellWiki_files/wikibits.js"><!-- wikibits js --></script><link rel="stylesheet" type="text/css" href="./99 questions 80 to 89 - HaskellWiki_files/KHTMLFixes.css">
		<!-- Head Scripts -->
		<script type="text/javascript" src="./99 questions 80 to 89 - HaskellWiki_files/ajax.js"></script>
<style type="text/css">/*<![CDATA[*/
.source-haskell {line-height: normal;}
.source-haskell li {line-height: normal;}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for haskell
 * CSS class: source-haskell, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.source-haskell .de1, .source-haskell .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal; font-style: normal;}
.source-haskell  {}
.source-haskell .head {}
.source-haskell .foot {}
.source-haskell .imp {font-weight: bold; color: red;}
.source-haskell li, .source-haskell li.li1 {font-weight: normal;}
.source-haskell li.li2 {font-weight: bold;}
.source-haskell .kw1 {color: #06c; font-weight: bold;}
.source-haskell .kw2 {color: #06c; font-weight: bold;}
.source-haskell .kw3 {font-weight: bold;}
.source-haskell .kw4 {color: #cccc00; font-weight: bold;}
.source-haskell .kw5 {color: maroon;}
.source-haskell .co1 {color: #5d478b; font-style: italic;}
.source-haskell .co2 {color: #339933; font-weight: bold;}
.source-haskell .coMULTI {color: #5d478b; font-style: italic;}
.source-haskell .es0 {background-color: #3cb371; font-weight: bold;}
.source-haskell .br0 {color: green;}
.source-haskell .sy0 {color: #339933; font-weight: bold;}
.source-haskell .st0 {background-color: #3cb371;}
.source-haskell .nu0 {color: red;}
.source-haskell .me1 {color: #060;}
.source-haskell .ln-xtra, .source-haskell li.ln-xtra, .source-haskell div.ln-xtra {color: #cc0; background-color: #ffc;}

/*]]>*/
</style>
<style type="text/css">/*<![CDATA[*/
@import "/haskellwiki/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=18000";
/*]]>*/
</style>		<script type="text/javascript" src="./99 questions 80 to 89 - HaskellWiki_files/index.php"><!-- site js --></script>
		<style type="text/css">/*<![CDATA[*/
@import "/haskellwiki/index.php?title=MediaWiki:Common.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=18000";
@import "/haskellwiki/index.php?title=MediaWiki:Hawiki.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=18000";
@import "/haskellwiki/index.php?title=-&action=raw&gen=css&maxage=18000&useskin=hawiki";
/*]]>*/</style>
	</head>
<body class="mediawiki ltr page-99_questions_80_to_89  hasGoogleVoiceExt">
   <div id="topbar" class="noprint">
	<div class="portlet noprint" id="p-personal">
		<h5>Personal tools</h5>
		<div class="pBody">
			<ul><li><a class="homebutton" href="http://www.haskell.org/haskellwiki/Haskell">Home</a></li>
				<li id="pt-login"><a href="http://www.haskell.org/haskellwiki/index.php?title=Special:Userlogin&returnto=99_questions/80_to_89" title="You are encouraged to log in, it is not mandatory however. [o]" accesskey="o">Log in / create account</a></li>
			</ul>
		</div>
	</div>
        	  <div id="p-search">
	    <div id="searchBody" class="pBody">
	       <form action="http://www.haskell.org/haskellwiki/index.php" id="searchform"><div>
	          <input type="hidden" name="title" value="">
	          <input id="searchInput" name="search" type="text" title="Search HaskellWiki [ctrl-f]" accesskey="f" value="">
				<input type="submit" name="go" class="searchButton" id="searchGoButton" value="Go" title="Go to a page with this exact name if exists">&nbsp;
				<input type="submit" name="fulltext" class="searchButton" id="mw-searchButton" value="Search" title="Search the pages for this text">

	         </div></form>
	    </div>
	  </div>
   </div>
	<div id="globalWrapper">
	<div class="portlet" id="p-logo">
		<a style="background-image: url(/wikistatic/haskellwiki_logo.png);" href="http://www.haskell.org/haskellwiki/Haskell" title="Main Page"></a>
	</div>
	<div id="column-content">
        <div id="notice-area" class="noprint">
        <!-- ?php $this->data['sitenotice'] = 'This is a test instance.  Do not edit, your changes will be lost.'; ? -->
			        </div>
        <div id="content-wrapper">
	<div id="p-cactions" class="portlet noprint">
		<h5>Views</h5>
		<div class="pBody">
			<ul>
	
				 <li id="ca-nstab-main" class="selected"><a href="./99 questions 80 to 89 - HaskellWiki_files/99 questions 80 to 89 - HaskellWiki.html" title="View the content page [c]" accesskey="c">Page</a></li>
				 <li id="ca-talk" class="new"><a href="http://www.haskell.org/haskellwiki/index.php?title=Talk:99_questions/80_to_89&action=edit" title="Discussion about the content page [t]" accesskey="t">Discussion</a></li>
				 <li id="ca-viewsource"><a href="http://www.haskell.org/haskellwiki/index.php?title=99_questions/80_to_89&action=edit" title="This page is protected. You can view its source. [e]" accesskey="e">View source</a></li>
				 <li id="ca-history"><a href="http://www.haskell.org/haskellwiki/index.php?title=99_questions/80_to_89&action=history" title="Past versions of this page. [h]" accesskey="h">History</a></li>			</ul>
		</div>
	</div>
                        <div id="content">
		<a name="top" id="top"></a>
                        <h1 id="firstHeading" class="firstHeading">99 questions/80 to 89</h1>
		<div id="bodyContent">
			<h3 id="siteSub">From HaskellWiki</h3>
			<div id="contentSub"><span class="subpages">&lt; <a href="http://www.haskell.org/haskellwiki/99_questions" class="mw-redirect" title="99 questions">99 questions</a></span></div>
			<div id="jump-to-nav">Jump to: <a href="http://www.haskell.org/haskellwiki/99_questions/80_to_89#column-one">navigation</a>, <a href="http://www.haskell.org/haskellwiki/99_questions/80_to_89#searchInput">search</a></div>			<!-- start content -->
			<p><br>
This is part of <a href="http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems" title="H-99: Ninety-Nine Haskell Problems">Ninety-Nine Haskell Problems</a>, based on <a href="https://prof.ti.bfh.ch/hew1/informatik3/prolog/p-99/" class="external text" title="https://prof.ti.bfh.ch/hew1/informatik3/prolog/p-99/" rel="nofollow">Ninety-Nine Prolog Problems</a>.
</p><p>If you want to work on one of these, put your name in the block so we know someone's working on it. Then, change n in your block to the appropriate problem number, and fill in the &lt;Problem description&gt;,&lt;example in lisp&gt;,&lt;example in Haskell&gt;,&lt;solution in haskell&gt; and &lt;description of implementation&gt; fields. 
</p>
<a name="Graphs"></a><h2> <span class="mw-headline">1  Graphs </span></h2>
<p>A graph is defined as a set of nodes and a set of edges, where each edge is a pair of nodes. 
</p><p><img src="./99 questions 80 to 89 - HaskellWiki_files/graph1.gif" alt="graph1.gif">
</p><p>There are several ways to represent graphs in Prolog. One method is to represent each edge separately as one clause (fact). In this form, the graph depicted below is represented as the following predicate: 
</p>
<pre>edge(h,g).
edge(k,f).
edge(f,b).
...
</pre>
<p>We call this <i>edge-clause</i> form. Obviously, isolated nodes cannot be represented. Another method is to represent the whole graph as one data object. According to the definition of the graph as a pair of two sets (nodes and edges), we may use the following Prolog term to represent the example graph:
</p>
<pre>graph([b,c,d,f,g,h,k],[e(b,c),e(b,f),e(c,f),e(f,k),e(g,h)])
</pre>
<p>We call this <i>graph-term</i> form. Note, that the lists are kept sorted, they are really <i>sets</i>, without duplicated elements. Each edge appears only once in the edge list; i.e. an edge from a node x to another node y is represented as e(x,y), the term e(y,x) is not present. <b>The graph-term form is our default representation.</b> In SWI-Prolog there are predefined predicates to work with sets. 
</p><p>A third representation method is to associate with each node the set of nodes that are adjacent to that node. We call this the <i>adjacency-list</i> form. In our example:
</p>
<pre>[n(b,[c,f]), n(c,[b,f]), n(d,[]), n(f,[b,c,k]), ...]
</pre>
<p>The representations we introduced so far are Prolog terms and therefore well suited for automated processing, but their syntax is not very user-friendly. Typing the terms by hand is cumbersome and error-prone. We can define a more compact and "human-friendly" notation as follows: A graph is represented by a list of atoms and terms of the type X-Y (i.e. functor '-' and arity 2). The atoms stand for isolated nodes, the X-Y terms describe edges. If an X appears as an endpoint of an edge, it is automatically defined as a node. Our example could be written as:
</p>
<pre>[b-c, f-c, g-h, d, f-b, k-f, h-g]
</pre>
<p>We call this the <i>human-friendly</i> form. As the example shows, the list does not have to be sorted and may even contain the same edge multiple times. Notice the isolated node d. (Actually, isolated nodes do not even have to be atoms in the Prolog sense, they can be compound terms, as in <tt>d(3.75,blue)</tt> instead of <tt>d</tt> in the example). 
</p><p><img src="./99 questions 80 to 89 - HaskellWiki_files/graph2.gif" alt="graph2.gif">
</p><p>When the edges are directed we call them arcs. These are represented by ordered pairs. Such a graph is called <b>directed graph</b>. To represent a directed graph, the forms discussed above are slightly modified. The example graph above is represented as follows: 
</p><p><i>Arc-clause form</i>
</p>
<pre>arc(s,u).
arc(u,r).
...
</pre>
<p><i>Graph-term form</i>
</p>
<pre>digraph([r,s,t,u,v],[a(s,r),a(s,u),a(u,r),a(u,s),a(v,u)])
</pre>
<p><i>Adjacency-list form</i>
</p>
<pre>[n(r,[]),n(s,[r,u]),n(t,[]),n(u,[r]),n(v,[u])]
</pre>
<p>Note that the adjacency-list does not have the information on whether it is a graph or a digraph.
</p><p><i>Human-friendly form</i>
</p>
<pre>[s &gt; r, t, u &gt; r, s &gt; u, u &gt; s, v &gt; u] 
</pre>
<p>Finally, graphs and digraphs may have additional information attached to nodes and edges (arcs). For the nodes, this is no problem, as we can easily replace the single character identifiers with arbitrary compound terms, such as <tt>city('London',4711)</tt>. On the other hand, for edges we have to extend our notation. Graphs with additional information attached to edges are called <b>labelled graphs</b>.
</p><p><img src="./99 questions 80 to 89 - HaskellWiki_files/graph3.gif" alt="graph3.gif">
</p><p><i>Arc-clause form</i>
</p>
<pre>arc(m,q,7).
arc(p,q,9).
arc(p,m,5).
</pre>
<p><i>Graph-term form</i>
</p>
<pre>digraph([k,m,p,q],[a(m,p,7),a(p,m,5),a(p,q,9)])
</pre>
<p><i>Adjacency-list form</i>
</p>
<pre>[n(k,[]),n(m,[q/7]),n(p,[m/5,q/9]),n(q,[])]
</pre>
<p>Notice how the edge information has been packed into a term with functor '/' and arity 2, together with the corresponding node.
</p><p><i>Human-friendly form</i>
</p>
<pre>[p&gt;q/9, m&gt;q/7, k, p&gt;m/5]
</pre>
<p>The notation for labelled graphs can also be used for so-called <b>multi-graphs</b>, where more than one edge (or arc) are allowed between two given nodes.
</p>
<a name="Problem_80"></a><h2> <span class="mw-headline">2  Problem 80 </span></h2>
<p>(***) Conversions
</p><p>Write predicates to convert between the different graph representations. With these predicates, all representations are equivalent; i.e. for the following problems you can always pick freely the most convenient form. The reason this problem is rated (***) is not because it's particularly difficult, but because it's a lot of work to deal with all the special cases.
</p><p>Example:
</p>
<pre>&lt;example in lisp&gt;
</pre>
<p>Example in Haskell:
</p>
<div dir="ltr" style="text-align: left;"><pre class="source-haskell"><span class="sy0">&lt;</span>example <span class="kw1">in</span> Haskell<span class="sy0">&gt;</span></pre></div>
<p><a href="http://www.haskell.org/haskellwiki/index.php?title=99_questions/Solutions/80&action=edit" class="new" title="99 questions/Solutions/80"> Solutions </a>
</p><p><br>        
</p>
<a name="Problem_81"></a><h2> <span class="mw-headline">3  Problem 81 </span></h2>
<p>(**) Path from one node to another one
</p><p>Write a function that, given two nodes a and b in a graph, returns all the acyclic paths from a to b.
</p><p>Example:
</p>
<pre>&lt;example in lisp&gt;
</pre>
<p>Example in Haskell:
</p>
<div dir="ltr" style="text-align: left;"><pre class="source-haskell">paths <span class="nu0">1</span> <span class="nu0">4</span> <span class="br0">[</span><span class="br0">(</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">2</span><span class="br0">)</span><span class="sy0">,</span><span class="br0">(</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">3</span><span class="br0">)</span><span class="sy0">,</span><span class="br0">(</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">3</span><span class="br0">)</span><span class="sy0">,</span><span class="br0">(</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">4</span><span class="br0">)</span><span class="sy0">,</span><span class="br0">(</span><span class="nu0">4</span><span class="sy0">,</span><span class="nu0">2</span><span class="br0">)</span><span class="sy0">,</span><span class="br0">(</span><span class="nu0">5</span><span class="sy0">,</span><span class="nu0">6</span><span class="br0">)</span><span class="br0">]</span>
<span class="br0">[</span><span class="br0">[</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">4</span><span class="br0">]</span><span class="sy0">,</span><span class="br0">[</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">4</span><span class="br0">]</span><span class="br0">]</span>
paths <span class="nu0">2</span> <span class="nu0">6</span> <span class="br0">[</span><span class="br0">(</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">2</span><span class="br0">)</span><span class="sy0">,</span><span class="br0">(</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">3</span><span class="br0">)</span><span class="sy0">,</span><span class="br0">(</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">3</span><span class="br0">)</span><span class="sy0">,</span><span class="br0">(</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">4</span><span class="br0">)</span><span class="sy0">,</span><span class="br0">(</span><span class="nu0">4</span><span class="sy0">,</span><span class="nu0">2</span><span class="br0">)</span><span class="sy0">,</span><span class="br0">(</span><span class="nu0">5</span><span class="sy0">,</span><span class="nu0">6</span><span class="br0">)</span><span class="br0">]</span>
<span class="br0">[</span><span class="br0">]</span></pre></div>
<p><a href="http://www.haskell.org/haskellwiki/99_questions/Solutions/81" title="99 questions/Solutions/81"> Solutions </a>
</p>
<a name="Problem_82"></a><h2> <span class="mw-headline">4  Problem 82 </span></h2>
<p>(*) Cycle from a given node
</p><p>Write a predicate cycle(G,A,P) to find a closed path (cycle) P starting at a given node A in the graph G. The predicate should return all cycles via backtracking.
</p><p>Example:
</p>
<pre>&lt;example in lisp&gt;
</pre>
<p>Example in Haskell:
</p>
<div dir="ltr" style="text-align: left;"><pre class="source-haskell">graph<span class="sy0">&gt;</span> <span class="kw3">cycle</span> <span class="nu0">2</span> <span class="br0">[</span><span class="br0">(</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">2</span><span class="br0">)</span><span class="sy0">,</span><span class="br0">(</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">3</span><span class="br0">)</span><span class="sy0">,</span><span class="br0">(</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">3</span><span class="br0">)</span><span class="sy0">,</span><span class="br0">(</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">4</span><span class="br0">)</span><span class="sy0">,</span><span class="br0">(</span><span class="nu0">4</span><span class="sy0">,</span><span class="nu0">2</span><span class="br0">)</span><span class="sy0">,</span><span class="br0">(</span><span class="nu0">5</span><span class="sy0">,</span><span class="nu0">6</span><span class="br0">)</span><span class="br0">]</span>
<span class="br0">[</span><span class="br0">[</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">4</span><span class="sy0">,</span><span class="nu0">2</span><span class="br0">]</span><span class="br0">]</span>
graph<span class="sy0">&gt;</span> <span class="kw3">cycle</span> <span class="nu0">1</span> <span class="br0">[</span><span class="br0">(</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">2</span><span class="br0">)</span><span class="sy0">,</span><span class="br0">(</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">3</span><span class="br0">)</span><span class="sy0">,</span><span class="br0">(</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">3</span><span class="br0">)</span><span class="sy0">,</span><span class="br0">(</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">4</span><span class="br0">)</span><span class="sy0">,</span><span class="br0">(</span><span class="nu0">4</span><span class="sy0">,</span><span class="nu0">2</span><span class="br0">)</span><span class="sy0">,</span><span class="br0">(</span><span class="nu0">5</span><span class="sy0">,</span><span class="nu0">6</span><span class="br0">)</span><span class="br0">]</span>
<span class="br0">[</span><span class="br0">]</span></pre></div>
<p><a href="http://www.haskell.org/haskellwiki/99_questions/Solutions/82" title="99 questions/Solutions/82"> Solutions </a>
</p>
<a name="Problem_83"></a><h2> <span class="mw-headline">5  Problem 83 </span></h2>
<p>(**) Construct all spanning trees 
</p><p>Write a predicate s_tree(Graph,Tree) to construct (by backtracking) all spanning trees of a given graph. With this predicate, find out how many spanning trees there are for the graph depicted to the left. The data of this example graph can be found in the file p83.dat. When you have a correct solution for the s_tree/2 predicate, use it to define two other useful predicates: is_tree(Graph) and is_connected(Graph). Both are five-minutes tasks!
</p><p>Example:
</p>
<pre>&lt;example in lisp&gt;
</pre>
<p>Example in Haskell:
</p>
<div dir="ltr" style="text-align: left;"><pre class="source-haskell"><span class="sy0">&lt;</span>example <span class="kw1">in</span> Haskell<span class="sy0">&gt;</span></pre></div>
<p><a href="http://www.haskell.org/haskellwiki/index.php?title=99_questions/Solutions/83&action=edit" class="new" title="99 questions/Solutions/83"> Solutions </a>
</p><p><br>        
</p>
<a name="Problem_84"></a><h2> <span class="mw-headline">6  Problem 84 </span></h2>
<p>(**) Construct the minimal spanning tree
</p><p>Write a predicate ms_tree(Graph,Tree,Sum) to construct the minimal spanning tree of a given labelled graph. Hint: Use the algorithm of Prim. A small modification of the solution of P83 does the trick. The data of the example graph to the right can be found in the file p84.dat.
</p><p>Example:
</p>
<pre>&lt;example in lisp&gt;
</pre>
<p>Example in Haskell:
</p>
<div dir="ltr" style="text-align: left;"><pre class="source-haskell"><span class="sy0">&lt;</span>example <span class="kw1">in</span> Haskell<span class="sy0">&gt;</span></pre></div>
<p><a href="http://www.haskell.org/haskellwiki/99_questions/Solutions/84" title="99 questions/Solutions/84"> Solutions </a>
</p><p><br>        
</p>
<a name="Problem_85"></a><h2> <span class="mw-headline">7  Problem 85 </span></h2>
<p>(**) Graph isomorphism
</p><p>Two graphs G1(N1,E1) and G2(N2,E2) are isomorphic if there is a bijection f: N1 -&gt; N2 such that for any nodes X,Y of N1, X and Y are adjacent if and only if f(X) and f(Y) are adjacent.
</p><p>Write a predicate that determines whether two graphs are isomorphic. Hint: Use an open-ended list to represent the function f.
</p><p>Example:
</p>
<pre>&lt;example in lisp&gt;
</pre>
<p>Example in Haskell:
</p>
<div dir="ltr" style="text-align: left;"><pre class="source-haskell"><span class="sy0">&lt;</span>example <span class="kw1">in</span> Haskell<span class="sy0">&gt;</span></pre></div>
<p><a href="http://www.haskell.org/haskellwiki/index.php?title=99_questions/Solutions/85&action=edit" class="new" title="99 questions/Solutions/85"> Solutions </a>
</p><p><br>        
</p>
<a name="Problem_86"></a><h2> <span class="mw-headline">8  Problem 86 </span></h2>
<p>(**) Node degree and graph coloration
</p><p>a) Write a predicate degree(Graph,Node,Deg) that determines the degree of a given node.
</p><p>b) Write a predicate that generates a list of all nodes of a graph sorted according to decreasing degree.
</p><p>c) Use Welch-Powell's algorithm to paint the nodes of a graph in such a way that adjacent nodes have different colors.
</p><p><br>
Example:
</p>
<pre>&lt;example in lisp&gt;
</pre>
<p>Example in Haskell:
</p>
<div dir="ltr" style="text-align: left;"><pre class="source-haskell"><span class="sy0">&lt;</span>example <span class="kw1">in</span> Haskell<span class="sy0">&gt;</span></pre></div>
<p><a href="http://www.haskell.org/haskellwiki/index.php?title=99_questions/Solutions/86&action=edit" class="new" title="99 questions/Solutions/86"> Solutions </a>
</p><p><br>        
</p>
<a name="Problem_87"></a><h2> <span class="mw-headline">9  Problem 87 </span></h2>
<p>(**) Depth-first order graph traversal (alternative solution)
</p><p>Write a predicate that generates a depth-first order graph traversal sequence. The starting point should be specified, and the output should be a list of nodes that are reachable from this starting point (in depth-first order).
</p><p>Example:
</p>
<pre>&lt;example in lisp&gt;
</pre>
<p>Example in Haskell:
</p>
<div dir="ltr" style="text-align: left;"><pre class="source-haskell"><span class="sy0">&lt;</span>example <span class="kw1">in</span> Haskell<span class="sy0">&gt;</span></pre></div>
<p><a href="http://www.haskell.org/haskellwiki/99_questions/Solutions/87" title="99 questions/Solutions/87"> Solutions </a>
</p><p><br>        
</p>
<a name="Problem_88"></a><h2> <span class="mw-headline">10  Problem 88 </span></h2>
<p>(**) Connected components (alternative solution)
</p><p>Write a predicate that splits a graph into its connected components.
</p><p>Example:
</p>
<pre>&lt;example in lisp&gt;
</pre>
<p>Example in Haskell:
</p>
<div dir="ltr" style="text-align: left;"><pre class="source-haskell"><span class="sy0">&lt;</span>example <span class="kw1">in</span> Haskell<span class="sy0">&gt;</span></pre></div>
<p><a href="http://www.haskell.org/haskellwiki/99_questions/Solutions/88" title="99 questions/Solutions/88"> Solutions </a>
</p><p><br>        
</p>
<a name="Problem_89"></a><h2> <span class="mw-headline">11  Problem 89 </span></h2>
<p>(**) Bipartite graphs
</p><p>Write a predicate that finds out whether a given graph is bipartite.
</p><p>Example:
</p>
<pre>&lt;example in lisp&gt;
</pre>
<p>Example in Haskell:
</p>
<div dir="ltr" style="text-align: left;"><pre class="source-haskell"><span class="sy0">&lt;</span>example <span class="kw1">in</span> Haskell<span class="sy0">&gt;</span></pre></div>
<p><a href="http://www.haskell.org/haskellwiki/99_questions/Solutions/89" title="99 questions/Solutions/89"> Solutions </a>
</p>
<!-- 
NewPP limit report
Preprocessor node count: 75/1000000
Post-expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:2473-0!1!0!1!en!2!edit=0 and timestamp 20130406200520 -->
<div class="printfooter">
Retrieved from "<a href="./99 questions 80 to 89 - HaskellWiki_files/99 questions 80 to 89 - HaskellWiki.html">http://www.haskell.org/haskellwiki/99_questions/80_to_89</a>"</div>
			<p class="catlinks"><a href="http://www.haskell.org/haskellwiki/Special:Categories" title="Special:Categories">Category</a>: <span dir="ltr"><a href="http://www.haskell.org/haskellwiki/Category:Tutorials" title="Category:Tutorials">Tutorials</a></span></p>			<!-- end content -->
						<div class="visualClear"></div>
		</div>
	</div>
		</div></div>
		<div id="column-one">
	<script type="text/javascript"> if (window.isMSIE55) fixalpha(); </script>
	<div class="generated-sidebar portlet" id="p-navigation">
		<h5>Navigation</h5>
		<div class="pBody">
			<ul>
				<li id="n-mainpage"><a href="http://www.haskell.org/haskellwiki/Haskell" title="Visit the Main Page [ctrl-z]" accesskey="z">Haskell</a></li>
				<li id="n-portal"><a href="http://www.haskell.org/haskellwiki/HaskellWiki:Community" title="About the project, what you can do, where to find things">Wiki community</a></li>
				<li id="n-recentchanges"><a href="http://www.haskell.org/haskellwiki/Special:Recentchanges" title="The list of recent changes in the wiki. [ctrl-r]" accesskey="r">Recent changes</a></li>
				<li id="n-randompage"><a href="http://www.haskell.org/haskellwiki/Special:Random" title="Load a random page [ctrl-x]" accesskey="x">Random page</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-tb">
		<h5>Toolbox</h5>
		<div class="pBody">
			<ul>
				<li id="t-whatlinkshere"><a href="http://www.haskell.org/haskellwiki/Special:Whatlinkshere/99_questions/80_to_89" title="List of all wiki pages that link here [ctrl-j]" accesskey="j">What links here</a></li>
				<li id="t-recentchangeslinked"><a href="http://www.haskell.org/haskellwiki/Special:Recentchangeslinked/99_questions/80_to_89" title="Recent changes in pages linked from this page [ctrl-k]" accesskey="k">Related changes</a></li>
<li id="t-upload"><a href="http://www.haskell.org/haskellwiki/Special:Upload" title="Upload files [ctrl-u]" accesskey="u">Upload file</a></li>
<li id="t-specialpages"><a href="http://www.haskell.org/haskellwiki/Special:Specialpages" title="List of all special pages [ctrl-q]" accesskey="q">Special pages</a></li>
				<li id="t-print"><a href="http://www.haskell.org/haskellwiki/index.php?title=99_questions/80_to_89&printable=yes" rel="alternate" title="Printable version of this page [ctrl-p]" accesskey="p">Printable version</a></li>				<li id="t-permalink"><a href="http://www.haskell.org/haskellwiki/index.php?title=99_questions/80_to_89&oldid=44302" title="Permanent link to this version of the page">Permanent link</a></li>			</ul>
		</div>
	</div>
		</div><!-- end of the left (by default at least) column -->
			<div class="visualClear"></div>
			<div id="footer">
				<div id="f-poweredbyico"><a href="http://www.mediawiki.org/"><img src="./99 questions 80 to 89 - HaskellWiki_files/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki"></a></div>
			<ul id="f-list">
					<li id="lastmod"> This page was last modified 01:36, 1 February 2012.</li>
					<li id="viewcount">This page has been accessed 19,478 times.</li>
					<li id="copyright">Recent content is available under <a href="http://www.haskell.org/haskellwiki/HaskellWiki:Copyrights" title="HaskellWiki:Copyrights">a simple permissive license</a>.</li>
					<li id="privacy"><a href="http://www.haskell.org/haskellwiki/HaskellWiki:Privacy_policy" title="HaskellWiki:Privacy policy">Privacy policy</a></li>
					<li id="about"><a href="http://www.haskell.org/haskellwiki/HaskellWiki:About" title="HaskellWiki:About">About HaskellWiki</a></li>
					<li id="disclaimer"><a href="http://www.haskell.org/haskellwiki/HaskellWiki:General_disclaimer" title="HaskellWiki:General disclaimer">Disclaimers</a></li>
			</ul>
		</div>
</div>

		<script type="text/javascript">if (window.runOnloadHook) runOnloadHook();</script>
<!-- Served in 0.152 secs. --><script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-15375175-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<div id="directions_extension" style="display: none;"></div></body></html>